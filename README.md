# Тестовое задание Mindbox на позицию SRE
Опишите решение для веб-приложения в kubernetes в виде yaml-манифеста. Оставляйте в коде комментарии по принятым решениям. Есть следующие вводные:

1. У нас мультизональный кластер (три зоны), в котором пять нод.
2. Приложение требует около 5-10 секунд для инициализации.
3. По результатам нагрузочного теста известно, что 4 пода справляются с пиковой нагрузкой.
4. На первые запросы приложению требуется значительно больше ресурсов CPU, в дальнейшем потребление ровное в районе 0.1 CPU. По памяти всегда “ровно” в районе 128M memory.
5. Приложение имеет дневной цикл по нагрузке – ночью запросов на порядки меньше, пик – днём.

Что хотим?
1. Хотим максимально отказоустойчивый deployment.
2. Хотим минимального потребления ресурсов от этого deployment’а.


## Содержание: 
- [Мультизональный кластер](#мультизональный-кластер)
- [Инициализация 5-10 секунд](#инициализация-5-10-секунд)
- [4 пода справляются с нагрузкой](#4-пода-справляются-с-нагрузкой)
- [Выделение ресурсов](#выделение-ресурсов)
- [Пик по нагрузке днём](#пик-по-нагрузке-днём)

## Мультизональный кластер
Поскольку в кластере есть три зоны, лучше всего раскидать все поды на эти три зоны. Тогда, если что-то пойдет не так в 
одной зоне (например, она упадет или там будут технические работы), приложение всё равно будет работать.

Код отвечающий за размещение подов на узлах в зонах eu-west-1,2,3:
```yaml
nodeAffinity:
  preferredDuringSchedulingIgnoredDuringExecution:
    - weight: 100
      preference:
        matchExpressions:
          - key: topology.kubernetes.io/zone
            operator: In
            values:
              - eu-west-1
              - eu-west-2
              - eu-west-3
```
Код отвечающий за размещение на разных нодах:
```yaml
podAntiAffinity:
  preferredDuringSchedulingIgnoredDuringExecution:
    - weight: 100
      podAffinityTerm:
        labelSelector:
          matchExpressions:
            - key: app
              operator: In
              values:
                - nginx
        topologyKey: "kubernetes.io/hostname"
```
В данном случае я использую ```preferredDuringSchedulingIgnoredDuringExecution```, а не ```requiredDuringSchedulingIgnoredDuringExecution```
благодаря чему, даже если одна зона будет недоступно приложение всё равно запуститься.

## Инициализация 5-10 секунд
Для выполнения этого условия я использую ```readnessProbe```, что позволяет не запускать трафик в поды, пока k8s не будет уверен, что
под готов к получению трафика:
```yaml
readinessProbe:
  httpGet:
    path: /healthz
    port: 8080
  initialDelaySeconds: 6
  periodSeconds: 5
```

## 4 пода справляются с нагрузкой
Для выполнения этого условия я помимо стандартной репликации ```replicas: 2``` использовал ещё и HPA (горизонтальное
масштабирование):
```yaml
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: nginx
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: nginx
  minReplicas: 1
  maxReplicas: 4
  metrics:
    - type: Resource
      resource:
        name: cpu
        target:
          type: Utilization
          averageUtilization: 70
```
Эта сущность будет масштабировать число реплик от 1 до 4, что позволит выдержать пиковую нагрузку и экономит ресурсы, 
т.к. у нас не будут висеть 4 пода, в те моменты, когда достаточно и 1.

## Выделение ресурсов
Для выполнения этого условия я задал минимальное(requests) и максимальное(limits) количество ресурсов:
```yaml
resources:
  limits:
    cpu: "1"
    memory: "128Mi"
  requests:
    cpu: "0.1"
    memory: "128Mi"
```
Так как по памяти всё стабильно меняем только CPU.

## Пик по нагрузке днём
Для выполнения этого условия используется VPA(вертикальное масштабирование) и HPA(горизонтальное масштабирование), что
позволит днём при нагрузке увеличить число реплик до 4-х и выделит каждой ресурсы до 1 СPU, а ночью если в этом нет
необходимости уменьшит число реплик до 1-й и выделит 0.1 CPU.